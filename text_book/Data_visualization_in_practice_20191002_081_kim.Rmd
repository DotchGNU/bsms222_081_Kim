---
title: "Chap 10. Data visualization in practice"
output: html_notebook
---

***

**Topic of this chapter**

1. faceting

2. time series plot 

3. transformations

4. ridge plot


*** 

# **10.1 Case study : new insights on poverty**

* **Topic : Myth of poverty**

1. [New insights on Poverty](https://www.ted.com/talks/hans_rosling_reveals_new_insights_on_poverty?language=en)

2. [The best stats you've ever seen](https://www.ted.com/talks/hans_rosling_shows_the_best_stats_you_ve_ever_seen)

* **Main question**

1. Is it a fair characterization of today’s world to say it is divided into western rich nations and the developing world in Africa, Asia and Latin America?

2. Has income inequality across countries worsened during the last 40 years?

```{r}
library(tidyverse)
library(dslabs)
data(gapminder)   #from gapminder foundation
str(gapminder)    #it's not tidyverse dataframe 
```

```{r}
gapminder %>% as.tibble()
```


## 10.1.1 Hans Rosling's quiz

Q. For each of the six pairs of countries below, which country do you think had the highest child mortality rates in 2015? Which pairs do you think are most similar?

1. Sri Lanka or Turkey

2. Poland or South Korea

3. Malaysia or Russia

4. Pakistan or Vietnam

5. Thailand or South Africa

> without data : prejudice that more developing countries will be in non-Europe

> with data

```{r}
inf_mor <- function(countries_name){
  gapminder %>% 
  filter(year == 2015 & country %in% countries_name) %>%
  select(country, infant_mortality)
}

cbind(inf_mor(c("Sri Lanka", "Poland", "Malaysia", "Pakistan", "Thailand")), 
      inf_mor(c("Turkey", "South Korea", "Russia", "Vietnam", "South Africa")))
```


***

# **10.2 Scatterplots**

> Where the preconceived notion came from? Western world vs developing world 

* Preconceived notion 1 

1. Western world -> small family with long life span

2. developing world -> large family with short life span


```{r}
filter(gapminder, year == 1962) %>%
  ggplot(aes(fertility, life_expectancy)) +
  geom_point()
```

Most points fall into two distinct categories:

1. Life expectancy around 70 years and 3 or less children per family.

2. Life expectancy lower then 65 years and more than 5 children per family.

```{r}
filter(gapminder, year == 1962) %>%
  ggplot(aes(fertility, life_expectancy, color = continent)) +
  geom_point()
```

> In 1962 , preconceived notion looks real. 



***

# **10.3 Faceting**

* seperating data to each group and plotting seperately

```{r}
filter(gapminder, year %in% c(1962, 2012)) %>%
  ggplot(aes(fertility, life_expectancy, col = continent)) + 
  geom_point() +
  facet_grid(~year)
```

```{r}
filter(gapminder, year %in% c(1962, 2012)) %>%
  ggplot(aes(fertility, life_expectancy, col = continent)) + 
  geom_point() +
  facet_grid(continent~year)
```

> `facet_grid(row~column)`



## 10.3.1 `facet_wrap`

```{r}
years <- c(1962, 1980, 1990, 2000, 2012)
continents <- c("Europe", "Asia")
gapminder %>%
  filter(year %in% years & continent %in% continents) %>%
  ggplot(aes(fertility, life_expectancy, col = continent)) +
  geom_point()+
  facet_wrap(~year, ncol=3)
```

* compare with `facet_grid`

  - we can set the number of column and row in `facet_wrap`

```{r}
years <- c(1962, 1980, 1990, 2000, 2012)
continents <- c("Europe", "Asia")
gapminder %>%
  filter(year %in% years & continent %in% continents) %>%
  ggplot(aes(fertility, life_expectancy, col = continent)) +
  geom_point()+
  facet_grid(~year)
```



## 10.3.2 Fixed scales for better comparisons

```{r}
install.packages("ggpubr") ##ggplot2 based publication ready plots
library(ggpubr)

past <- filter(gapminder, year %in% c("1962")) %>%
  ggplot(aes(fertility,life_expectancy, col = continent)) + 
  geom_point() 

present <- filter(gapminder, year %in% c("2012")) %>%
  ggplot(aes(fertility,life_expectancy, col = continent)) + 
  geom_point()

ggarrange(past, present,
         labels = c("A","B"))
```

```{r}
filter(gapminder, year %in% c("1962", "2012")) %>%
  ggplot(aes(fertility, life_expectancy, col = continent)) +
  geom_point() +
  facet_grid(~year)
```


> when we use `ggarange`, the scale is not matched automatically 
> `facet` fixed scales for better comparisions 



***

# 10.4 Time series plots

* time series plots with one variable

```{r}
gapminder %>%
  filter(country == "United States") %>%
  ggplot(aes(year, fertility)) +
  geom_point()
```

```{r}
gapminder %>%
  filter(country == "United States") %>%
  ggplot(aes(year, fertility)) +
  geom_line()
```

* time series plot with several variables 

```{r}
countries <- c("South Korea","Germany")

gapminder %>% filter(country %in% countries) %>% 
  ggplot(aes(year,fertility)) +
  geom_line()
```

  - we should make group in `aes` 

```{r}
gapminder %>% filter(country %in% countries & !is.na(fertility)) %>%
  ggplot(aes(year, fertility, color = country)) +
  geom_line()
```



## 10.4.1 Labels instead of legends

```{r}
# x, y stand for the position of labels

#labels <- data.frame(country = countries, x = c(1975, 1965), y = c(60, 72))
labels <- tibble(country = countries, x = c(1975, 1965), y = c(60, 72))

gapminder %>%
  filter(country %in% countries) %>%
  ggplot(aes(year, life_expectancy, col = country)) + 
  geom_line() +
  geom_text(data = labels, aes(x, y, label = country), size = 5) +
  theme(legend.position = "none")
```



***

# 10.5 Data transformation 

**Question 2 : Do poor countries have become poorer and rich countries become richer?**

```{r}
gapminder <- gapminder %>% mutate(dollars_per_day = gdp/population/365)
```



## 10.5.1 Log transformation

```{r}
#per day incomes from 1970

past_year <- 1970

gapminder %>%
  filter(year == past_year, !is.na(gdp)) %>%
  ggplot(aes(dollars_per_day)) + 
  geom_histogram(binwidth = 1, color = "black") 
```

In this plot, we see that for the majority of countries, averages are below \$10 a day. However, the majority of the x-axis is dedicated to the 35 countries with averages above \$10. So the plot is not very informative about countries with values below \$10 a day.

> less informative about countries with values below \$10 a day 

```{r}
gapminder %>% 
  filter(year == past_year & !is.na(gdp)) %>%
  ggplot(aes(log2(dollars_per_day))) + 
  geom_histogram(binwidth = 1, color = "black")
```

> *close-up* of the mid to lower income countries 

> Log transformation provides an informative way to analyze one-side skewed data.



## 10.5.2 Which base? 

> common base : 2, $e$, 10 

> when using $e$, the scale is not intuitive or easy to interpret. 

For an example in which base 10 makes more sense, consider population sizes. A log base 10 is preferable since the range for these is:

```{r}
filter(gapminder, year == past_year) %>%
  summarize(min = min(population), max = max(population))
```

Here is the histogram of the transformed values:

```{r}
gapminder %>%
  filter(year == past_year) %>%
  ggplot(aes(log10(population))) + 
  geom_histogram(binwidth = 0.5, color = "black")
```



## 10.5.3 Transform the values or the scale? 

> `scale_x_continuous` function shows the real value as a scale, instead of logging values. 

> `scale_x_continuous(trans "log10")` = `scale_x_log10()`

```{r}
gapminder %>%
  filter(year == past_year & !is.na(gdp)) %>%
  ggplot(aes(dollars_per_day)) + 
  geom_histogram(binwidth = 1, color = "black") + 
  scale_x_continuous(trans = "log2")
```

* argument of `scale_x_continuous(trans=)`

 1. `sqrt` : square 
 
 2. `logit` : logistic transformation is useful when plotting proportions between 0 and 1.
 
 3. `reverse` : reverse transformation is useful when we want smaller values to be on the right or on top. 



***

#10.6 Visualizing multimodal distributions

* *modes* : *bumps* in the histogram. the value with the highest frequency 

  - *local modes* : goes up and down again -> *multiple modes*
  
* normal distribution -> monomodality 

* data above -> bimodality 

  - This bimodality is consistent with a dichotomous world made up of countries with average incomes less than $8 (3 in the log 2 scale) a day and countries above that.
  
  
***

#10.7 Comparing multiple distribution with boxplots and ridge plots 

```{r}
p <- gapminder %>% 
  filter(year == past_year & !is.na(gdp)) %>%
  ggplot(aes(region, dollars_per_day))
p + geom_point()
```

* We can rotate the axes with `coord_flip` or we can rotate the labels by changing the `theme` through `element_text`. The `hjust = 1` justifies the text so that it is next to the axis.

```{r}
p + geom_point() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1 ))
```

> By default, the regions are ordered alphabetically. But there is no practical reason! 
> In general, **do not order alphabetically**

> Data exploration is often made easier if we order the strata by some **interpretable quantity**

```{r}
p <- gapminder %>%
  filter(year == past_year & !is.na(gdp)) %>%
  mutate(region = reorder(region, dollars_per_day, FUN = median)) %>% # `FUN` : orderign criteria / ordering by median value
  ggplot(aes(region, dollars_per_day)) +
  geom_point() + 
  theme(axis.text.x = element_text(angle = 90, hjust =1))
p
```

* `reorder()`

* Q ) `mutate`는 열을 추가하는 함수. 그런데 `mutate(region = reorder())`은 원래 있던 열을 다른 열을 기준으로 재 정렬만 하는 과정. 

  - `reorder`를 쓰더라도 dataframe 자체의 순서는 바뀌지 않는다? (section 3.5.4 다시보기)
  
  - 그럼에도 불구하고 plot에서는 순서가 바뀐다. 

```{r}
a <- gapminder %>%
  filter(year == past_year & !is.na(gdp)) %>%
  select(region, dollars_per_day) 

a %>% mutate(region = reorder(region, dollars_per_day, FUN = median)) 
```

* we can see two clear groups with log transformation 

```{r}
p + scale_y_continuous(trans = "log2")
```


## 10.7.1 Boxplot


```{r}
gapminder <- gapminder %>%
  mutate(group = case_when(
    region %in% c("Western Europe", "Northern Europe","Southern Europe", 
                    "Northern America", "Australia and New Zealand") ~ "West",
    region %in% c("Eastern Asia", "South-Eastern Asia") ~ "East Asia", 
    region %in% c("Caribbean", "Central America", "South America") ~ "Latin America", 
    continent == "Africa" & region != "North Africa" ~ "Sub-Saharan Africa",
    TRUE ~ "Others"))
```

We turn this `group` variable into a **factor** to control the order of the levels:

```{r}
gapminder <- gapminder %>%
  mutate(group = factor(group,
                        levels = c("Others", "Latin America", "East Asia", "Sub-Saharan Africa", "West")))
```

* box plot with outlier 

```{r}
p <- gapminder %>%
  filter(year == past_year & !is.na(gdp)) %>%
  ggplot(aes(group, dollars_per_day)) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_y_continuous(trans = "log2") +
  xlab("")
p
```

* Box plot with showing all data
Boxplots have the limitation that by summarizing the data into five numbers, we might miss important characteristics of the data. One way to avoid this is by showing the data.

```{r}
p + geom_point(alpha = 0.5)
```



## 10.7.2 Ridge plots

* ridge plots : histogram with smooth densities

  - package **ggridges**

```{r}
#install.packages("ggridges")
library(ggridges)

p <- gapminder %>%
  filter(year == past_year & !is.na(dollars_per_day)) %>%
  ggplot(aes(dollars_per_day, group)) + 
  scale_x_continuous(trans = "log2")
p + geom_density_ridges()
```

If the number of data points is small enough, we can add them to the ridge plot using the following code:

```{r}
p + geom_density_ridges(jittered_points = TRUE)
```

Make it more tidy, we can use *rug representation* : 

```{r}
p + geom_density_ridges(jittered_points = TRUE,
                        position = position_points_jitter(width = 0.05, height = 0),
                        point_shape = '|', point_size = 3, point_alpha = 1, alpha = 0.7)
```


## 10.7.3 Example : 1970 versus 2010 income distributions 

**Q) Data exploration clearly shows that in 1970 there was a “west versus the rest” dichotomy. But does this dichotomy persist?**

```{r}
past_year <- 1970
present_year <- 2010
gapminder %>%
  filter(year %in% c(past_year, present_year) & !is.na(gdp)) %>%
  mutate(west = ifelse(group == "West", "West", "Developing")) %>%
  ggplot(aes(dollars_per_day)) + 
  geom_histogram(binwidth = 1, color = "black") +
  scale_x_continuous(trans = "log2") +
  facet_grid(year ~ west)
```

Before we interpret the findings of this plot, we notice that there are more countries represented in the 2010 histograms than in 1970: the total counts are larger. One reason for this is that several countries were founded after 1970. For example, the Soviet Union divided into several countries during the 1990s. Another reason is that data was available for more countries in 2010.

We remake the plots using only countries with data available for both years. In the data wrangling part of this book, we will learn **tidyverse** tools that permit us to write efficient code for this, but here we can use simple code using the `intersect` function:

```{r}
country_list_1 <- gapminder %>% 
  filter(year == past_year & !is.na(dollars_per_day)) %>% 
  pull(country)

country_list_2 <- gapminder %>% 
  filter(year == present_year & !is.na(dollars_per_day)) %>% 
  pull(country)
      
country_list <- intersect(country_list_1, country_list_2)
```

```{r}
past_year <- 1970
present_year <- 2010
gapminder %>%
  filter(year %in% c(past_year, present_year) & country %in% country_list & !is.na(gdp)) %>%
  mutate(west = ifelse(group == "West", "West", "Developing")) %>%
  ggplot(aes(dollars_per_day)) + 
  geom_histogram(binwidth = 1, color = "black") +
  scale_x_continuous(trans = "log2") +
  facet_grid(year ~ west)
```

We now see that the rich countries have become a bit richer, but percentage-wise, the poor countries appear to have improved more. In particular, we see that the proportion of developing countries earning more than $16 a day increased substantially.

To see which specific regions improved the most, we can remake the boxplots we made above, but now adding the year 2010 and then using facet to compare the two years.

```{r}
gapminder %>% 
  filter(year %in% c(past_year, present_year) & country %in% country_list) %>%
  ggplot(aes(group, dollars_per_day)) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_y_continuous(trans = "log2") +
  xlab("") +
  facet_grid(. ~ year)
```

 In general, comparisons are easier when data are plotted next to each other.
 
```{r}
gapminder %>% 
  filter(year %in% c(past_year, present_year) & country %in% country_list) %>%
  mutate(year = factor(year)) %>%
  ggplot(aes(group, dollars_per_day, fill = year)) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_y_continuous(trans = "log2") +
  xlab("") 
```

* Q) Then total income has been changed? 

* Q) Is the gap continuously maintained?

```{r}
gapminder %>%
  filter(year %in% c(past_year, present_year) & country %in% country_list) %>%
  ggplot(aes(dollars_per_day)) +
  geom_density(fill="grey") +
  scale_x_continuous(trans = "log2") +
  facet_grid(.~year)
```

Q) Then did poor countries become richer, or rich countries become poorer? 

```{r}
gapminder %>%
  filter(year %in% c(past_year, present_year) & country %in% country_list) %>%
  mutate(group = ifelse(group == "West", "West", "Developing")) %>%
  ggplot(aes(dollars_per_day, fill = group)) +
  scale_x_continuous(trans = "log2") +
  geom_density(alpha = 0.2) + 
  facet_grid(year ~ .)
```



## 10.7.4 Accessing computed variables

To have the areas of these densities be proportional to the size of the groups, we can simply multiply the y-axis values by the size of the group. From the geom_density help file, we see that the functions compute a variable called count that does exactly this. We want this variable to be on the y-axis rather than the density.

In ggplot2, we access these variables by surrounding the name with two dots `..`. We will use the following mapping:

```{markdwon}
aes(x = dollars_per_daym y=..count..) # converting frequency to count
```

```{r}
p <- gapminder %>%
  filter(year %in% c(past_year, present_year) & country %in% country_list) %>%
  mutate(group = ifelse(group == "West", "West", "Developing")) %>%
  ggplot(aes(dollars_per_day, y = ..count.., fill =group)) +
  scale_x_continuous(trans = "log2", limit = c(0.125,300))
p + geom_density(alpha = 0.2) +
  facet_grid(year ~.)
```

If we want the densities to be smoother, we use the `bw`(bandwidth) argument so that the same bandwidth is used in each density. We selected 0.75 after trying out several values.

```{r}
p + geom_density(alpha = 0.2, bw = 0.75) + facet_grid(year ~ .)
```

> The distribution of developing world has been changed! 

* Let's explore more detaily. 

```{r}
gapminder %>%
  filter(year %in% c(past_year, present_year) & !is.na(dollars_per_day)) %>%
  ggplot(aes(dollars_per_day, group)) +
  scale_x_continuous(trans = "log2") +
  geom_density_ridges(adjust = 1.5) +
  facet_grid(.~year)
```

Another way to achieve this is by stacking the densities on top of each other:

```{r}
gapminder %>%
      filter(year %in% c(past_year, present_year) & country %in% country_list) %>%
  group_by(year) %>%
  mutate(weight = population/sum(population)*2) %>%
  ungroup() %>%
  ggplot(aes(dollars_per_day, fill = group)) +
  scale_x_continuous(trans = "log2", limit = c(0.125, 300)) + 
  geom_density(alpha = 0.2, bw = 0.75, position = "stack") + facet_grid(year ~ .) 
```

Here we can clearly see how the distributions for East Asia, Latin America and others shift markedly to the right. While Sub-Saharan Africa remains stagnant.

Notice that we order the levels of the group so that the West’s density are plotted first, then Sub-Saharan Africa. Having the two extremes plotted first allows us to see the remaining bimodality better.

## 10.7.5 Weighted densities

As a final point, we note that these distributions weigh every country the same. So if most of the population is improving, but living in a very large country, such as China, we might not appreciate this. We can actually weight the smooth densities using the weight `mapping` argument. The plot then looks like this:

> Q) how to make this plot? how to use `mapping` argument? >> check 

![weighted](https://rafalab.github.io/dsbook/book_files/figure-html/income-smooth-density-counts-by-region-year-weighted-1.png)

This particular figure shows very clearly how the income distribution gap is closing with most of the poor remaining in Sub-Saharan Africa.



*** 

# 10.8 The ecological fallacy and importance of showing the data
 

Throughout this section, we have been comparing regions of the world. We have seen that, on average, some regions do better than others. In this section, we focus on describing the importance of variability within the groups when examining the relationship between a country’s infant mortality rates and average income.

We start by comparing these quantities across regions, but before doing this, we define a few more regions:

```{r}
gapminder <- gapminder %>% 
  mutate(group = case_when(
    region %in% c("Western Europe", "Northern Europe","Southern Europe", 
                    "Northern America", "Australia and New Zealand") ~ "West",
    region %in% "Northern Africa" ~ "Northern Africa",
    region %in% c("Eastern Asia", "South-Eastern Asia") ~ "East Asia",
    region == "Southern Asia"~ "Southern Asia",
    region %in% c("Central America", "South America", "Caribbean") ~ "Latin America",
    continent == "Africa" & region != "Northern Africa" ~ "Sub-Saharan Africa",
    region %in% c("Melanesia", "Micronesia", "Polynesia") ~ "Pacific Islands"))
```

> 지역을 어떻게 정의하느냐도 매우 중요한 point

```{r}
surv_income <- gapminder %>% 
  filter(year %in% present_year & !is.na(gdp) & 
           !is.na(infant_mortality) & !is.na(group)) %>%
  group_by(group) %>%
  summarize(income = sum(gdp)/sum(population)/365,
            infant_survival_rate = 
              1 - sum(infant_mortality/1000*population)/sum(population)) 

surv_income %>% arrange(income)
```

```{r}
surv_income %>% ggplot(aes(income, infant_survival_rate, color = group)) +
  geom_point() + 
  scale_x_continuous(trans = "log2")
```

In this plot we introduce the use of the `limit` argument, which lets us change the range of the axes. We are making the range larger than the data requires because we will later compare this plot to one with more variability and we want the ranges to be the same. We also introduce the `breaks` argument, which lets us set the location of the axes labels. Finally, we introduce a new transformation, the logistic transformation.


## 10.8.1 Logistic transformation

The logistic or logit transformation for a proportion or rate $p$ is defined as
$$
f(p) = log(p/1-p)
$$
When $p$ is a proportion or probability, the quantity that is being logged, $p / ( 1 − p )$ , is called the odds. In this case $p$ is the proportion of infants that survived. The odds tell us how many more infants are expected to survive than to die. The log transformation makes this symmetric. If the rates are the same, then the log odds is 0. Fold increases or decreases turn into positive and negative increments respectively. This scale is useful when we want to highlight differences near 0 or 1. For survival rates this is important because a survival rate of 90% is unacceptable, while a survival of 99% is relatively good. We would much prefer a survival rate closer to 99.9%. We want our scale to highlight these difference and the logit does this. Note that 99.9/0.1 is about 10 times bigger than 99/1 which is about 10 times larger than 90/10. By using the log, these fold changes turn into constant increases. 10.8.2 Show the data

## 10.8.2 Show the data

![image](https://rafalab.github.io/dsbook/book_files/figure-html/ecological-fallacy-all-data-1.png)

```
filter(gapminder, year == 2012) %>%
  mutate(p_infant_mortality = 1-infant_mortality) %>%
#  filter(!is.na(p_infant_mortality) & !is.na(dollars_per_day)) %>%
  ggplot(aes(dollars_per_day, p_infant_mortality, color = group)) +
  geom_point() 
```


